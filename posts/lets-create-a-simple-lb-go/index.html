<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Let&#39;s Create a Simple Load Balancer With Go - kasvith.me - a personal blog space</title><meta name=renderer content=webkit><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content=no-transform><meta http-equiv=cache-control content=no-siteapp><meta name=theme-color content=#f8f5ec><meta name=msapplication-navbutton-color content=#f8f5ec><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=#f8f5ec><meta name=author content="Kasun Vithanage"><meta name=description content="Load Balancers plays a key role in Web Architecture. In this post we are going to develop a simple load balancer with power of Go"><meta name=keywords content=go,golang,load-balancer,loadbalancer><meta name=google-site-verification content=WWrc_VbA0fevsERwTdmBSfiA2udWJ3vJSyfMiny5t00><meta name=generator content="Hugo 0.58.3 with theme even"><link rel=canonical href=https://kasvith.me/posts/lets-create-a-simple-lb-go/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/dist/even.c2a46f00.min.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property=og:title content="Let's Create a Simple Load Balancer With Go"><meta property=og:description content="Load Balancers plays a key role in Web Architecture. In this post we are going to develop a simple load balancer with power of Go"><meta property=og:type content=article><meta property=og:url content=https://kasvith.me/posts/lets-create-a-simple-lb-go/><meta property=article:published_time content=2019-11-09T00:11:56+05:30><meta property=article:modified_time content=2020-05-14T22:29:38+05:30><meta itemprop=name content="Let's Create a Simple Load Balancer With Go"><meta itemprop=description content="Load Balancers plays a key role in Web Architecture. In this post we are going to develop a simple load balancer with power of Go"><meta itemprop=datePublished content=2019-11-09T00:11:56&#43;05:30><meta itemprop=dateModified content=2020-05-14T22:29:38&#43;05:30><meta itemprop=wordCount content=2345><meta itemprop=keywords content=go,golang,load-balancer,><meta name=twitter:card content=summary><meta name=twitter:title content="Let's Create a Simple Load Balancer With Go"><meta name=twitter:description content="Load Balancers plays a key role in Web Architecture. In this post we are going to develop a simple load balancer with power of Go"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>kasvith</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/posts/><li class=mobile-menu-item>Posts</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>kasvith</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/posts/>Posts</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Let&#39;s Create a Simple Load Balancer With Go</h1><div class=post-meta><span class=post-time>2019-11-09</span><div class=post-category><a href=/categories/go/>go</a></div><span class=more-meta>2345 words</span>
<span class=more-meta>12 mins read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#how-does-our-simple-load-balancer-work>How does our simple load balancer work</a></li><li><a href=#round-robin-selection>Round Robin Selection</a></li><li><a href=#lets-define-some-structs>Lets define some structs</a></li><li><a href=#use-of-the-reverseproxy>Use of the ReverseProxy</a></li><li><a href=#selection-process>Selection Process</a></li><li><a href=#picking-up-an-alive-backend>Picking up an alive backend.</a></li><li><a href=#avoid-race-conditions-in-backend-struct>Avoid Race Conditions in Backend struct</a></li><li><a href=#lets-load-balance-requests>Lets load balance requests</a></li><li><a href=#route-traffic-only-to-healthy-backends>Route traffic only to healthy backends</a></li><li><a href=#actively-checking-for-healthy-backends>Actively checking for healthy backends</a></li><li><a href=#use-of-context>Use of context</a></li><li><a href=#passive-health-checks>Passive health checks</a></li><li><a href=#conclusion>Conclusion</a></li></ul></li></ul></nav></div></div><div class=post-content><figure class=align-center><img src=/img/lets-create-a-load-balancer/featured.png></figure><p>Load Balancers plays a key role in Web Architecture. They allow distributing load among a set of backends. This makes services more scalable.
Also since there are multiple backends configured the service become highly available as load balancer can pick up a working server in case of a failure.</p><p>After playing with professional Load Balancers like <a href=https://www.nginx.com/>NGINX</a> I tried creating a simple Load Balancer for fun.
I implemented it using <a href=https://golang.org/>Golang</a>. Go is a modern language which supports concurrency as a first-class citizen.
Go has a rich standard library which allows writing high-performance applications with fewer lines of codes. It also produces a statically linked single binary for easy distributions.</p><h2 id=how-does-our-simple-load-balancer-work>How does our simple load balancer work</h2><p>Load Balancers have different strategies for distributing the load across a set of backends.</p><p>For example,</p><ul><li><strong>Round Robin</strong> - Distribute load equally, assumes all backends have the same processing power</li><li><strong>Weighted Round Robin</strong> - Additional weights can be given considering the backend&rsquo;s processing power</li><li><strong>Least Connections</strong> - Load is distributed to the servers with least active connections</li></ul><p>For our simple load balancer, we would try implementing the simplest one among these methods, <strong>Round Robin</strong>.</p><figure class=align-center><img src=/img/lets-create-a-load-balancer/lb-archi.png alt="A Round Robin Load Balancer"><figcaption><p>A Round Robin Load Balancer</p></figcaption></figure><h2 id=round-robin-selection>Round Robin Selection</h2><p>Round Robin is simple in terms. It gives equal opportunities for workers to perform tasks in turns.</p><figure class=align-center><img src=/img/lets-create-a-load-balancer/lb-rr.png alt="Round Robin Selection on incoming requests"><figcaption><p>Round Robin Selection on incoming requests</p></figcaption></figure><p>As shown in the figure about this happens cyclically. But we can&rsquo;t <em>directly</em> use that aren&rsquo;t we?</p><p><strong>What if a backend is down?</strong> We probably don&rsquo;t want to route traffic there.
So this cannot be directly used unless we put some conditions on it. We need to <strong>route traffic only to backends which are up and running</strong>.</p><h2 id=lets-define-some-structs>Lets define some structs</h2><p>After revising the plan, we know now we want a way to track all the details about a Backend.
We need to track whether it&rsquo;s alive or dead and also keep track of the Url as well.</p><p>We can simply define a struct like this to hold our backends.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>Backend</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>URL</span>          <span class=o>*</span><span class=nx>url</span><span class=p>.</span><span class=nx>URL</span>
  <span class=nx>Alive</span>        <span class=kt>bool</span>
  <span class=nx>mux</span>          <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
  <span class=nx>ReverseProxy</span> <span class=o>*</span><span class=nx>httputil</span><span class=p>.</span><span class=nx>ReverseProxy</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><p>Don&rsquo;t worry <strong>I will reason about the fields in the <code>Backend</code></strong>.</p><p>Now we need a way to track all the backends in our load balancer, for that we can simply use a Slice. And also a counter variable.
We can define it as <strong><code>ServerPool</code></strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>ServerPool</span> <span class=kd>struct</span> <span class=p>{</span>
  <span class=nx>backends</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Backend</span>
  <span class=nx>current</span>  <span class=kt>uint64</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><h2 id=use-of-the-reverseproxy>Use of the ReverseProxy</h2><p>As we already identified, the sole purpose of the load balancer is to route traffic to different backends and return the results to the original client.</p><p>According to Go&rsquo;s documentation,</p><blockquote><p>ReverseProxy is an HTTP Handler that takes an incoming request and sends it to another server, proxying the response back to the client.</p></blockquote><p><strong>Which is exactly what we want</strong>. There is no need to reinvent the wheel. We can simply relay our original requests through the <code>ReverseProxy</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>u</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>url</span><span class=p>.</span><span class=nf>Parse</span><span class=p>(</span><span class=s>&#34;http://localhost:8080&#34;</span><span class=p>)</span>
<span class=nx>rp</span> <span class=o>:=</span> <span class=nx>httputil</span><span class=p>.</span><span class=nf>NewSingleHostReverseProxy</span><span class=p>(</span><span class=nx>u</span><span class=p>)</span>
  
<span class=c1>// initialize your server and add this as handler
</span><span class=c1></span><span class=nx>http</span><span class=p>.</span><span class=nf>HandlerFunc</span><span class=p>(</span><span class=nx>rp</span><span class=p>.</span><span class=nx>ServeHTTP</span><span class=p>)</span></code></pre></td></tr></table></div></div><p>With <code>httputil.NewSingleHostReverseProxy(url)</code> we can initialize a reverse proxy which would relay requests to the passed <code>url</code>. In the above example, all the requests are now passed to localhost:8080 and the results are sent back to the original client. You can find more examples here.</p><p>If we take a look at ServeHTTP method signature, it has the signature of an HTTP handler, that&rsquo;s why we could pass it to the <code>HandlerFunc</code> in <code>http</code>.</p><p>You can find more examples in <a href=https://golang.org/pkg/net/http/httputil/#ReverseProxy>docs</a>.</p><p>For our simple load balancer we could initiate the <code>ReverseProxy</code> with the associated <code>URL</code> in the <code>Backend</code>, so that <code>ReverseProxy</code> will route our
requests to the <code>URL</code>.</p><h2 id=selection-process>Selection Process</h2><p>We need to <strong>skip dead backends</strong> during the next pick. But to do anything we need a way to count.</p><p>Multiple clients will connect to the load balancer and when each of them requests a next peer to pass the traffic on race conditions could occur.
To prevent it we could lock the <code>ServerPool</code> with a <code>mutex</code>. But that would be an overkill, besides we don&rsquo;t want to lock the ServerPool at all.
We just want to increase the counter by one</p><p>To meet that requirement, the ideal solution is to make this increment atomically. And Go supports that well via <code>atomic</code> package.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>ServerPool</span><span class=p>)</span> <span class=nf>NextIndex</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
  <span class=k>return</span> <span class=nb>int</span><span class=p>(</span><span class=nx>atomic</span><span class=p>.</span><span class=nf>AddUint64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>s</span><span class=p>.</span><span class=nx>current</span><span class=p>,</span> <span class=nb>uint64</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span> <span class=o>%</span> <span class=nb>uint64</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>backends</span><span class=p>)))</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><p>In here, we are increasing the current value by one atomically and returns the index by modding with the length of the slice.
Which means the value always will be between 0 and length of the slice. In the end, we are interested in a particular index, not the total count.</p><h2 id=picking-up-an-alive-backend>Picking up an alive backend.</h2><p>We already know that our requests are routed in a cycle for each backend. All we have to skip dead ones, that&rsquo;s it.</p><p><code>GetNext()</code> always return a value that&rsquo;s capped between 0 and the length of the slice. At any point, we get a next peer and if it&rsquo;s not alive we would have to search through the slice in a cycle.</p><figure class=align-center><img src=/img/lets-create-a-load-balancer/lb-slice-traverse.png alt="Traverse the slice as a cycle"><figcaption><p>Traverse the slice as a cycle</p></figcaption></figure><p>As shown in the figure above, we want to traverse from next to the entire list, which can be done simply by traversing <code>next + length</code>
But to pick an index, we want to cap it between slice length. It can be easily done with modding operation.</p><p>After we find a working backend through the search, we mark it as the current one.</p><p>Below you can see the code for the above operation.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// GetNextPeer returns next active peer to take a connection
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>ServerPool</span><span class=p>)</span> <span class=nf>GetNextPeer</span><span class=p>()</span> <span class=o>*</span><span class=nx>Backend</span> <span class=p>{</span>
  <span class=c1>// loop entire backends to find out an Alive backend
</span><span class=c1></span>  <span class=nx>next</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>.</span><span class=nf>NextIndex</span><span class=p>()</span>
  <span class=nx>l</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>backends</span><span class=p>)</span> <span class=o>+</span> <span class=nx>next</span> <span class=c1>// start from next and move a full cycle
</span><span class=c1></span>  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>next</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>l</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
    <span class=nx>idx</span> <span class=o>:=</span> <span class=nx>i</span> <span class=o>%</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>backends</span><span class=p>)</span> <span class=c1>// take an index by modding with length
</span><span class=c1></span>    <span class=c1>// if we have an alive backend, use it and store if its not the original one
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>s</span><span class=p>.</span><span class=nx>backends</span><span class=p>[</span><span class=nx>idx</span><span class=p>].</span><span class=nf>IsAlive</span><span class=p>()</span> <span class=p>{</span>
      <span class=k>if</span> <span class=nx>i</span> <span class=o>!=</span> <span class=nx>next</span> <span class=p>{</span>
        <span class=nx>atomic</span><span class=p>.</span><span class=nf>StoreUint64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>s</span><span class=p>.</span><span class=nx>current</span><span class=p>,</span> <span class=nb>uint64</span><span class=p>(</span><span class=nx>idx</span><span class=p>))</span> <span class=c1>// mark the current one
</span><span class=c1></span>      <span class=p>}</span>
      <span class=k>return</span> <span class=nx>s</span><span class=p>.</span><span class=nx>backends</span><span class=p>[</span><span class=nx>idx</span><span class=p>]</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><h2 id=avoid-race-conditions-in-backend-struct>Avoid Race Conditions in Backend struct</h2><p>There is a serious issue we need to consider. Our <code>Backend</code> structure has a variable which could be
modified or accessed by different goroutines same time.</p><p>We know there would be more goroutines reading from this rather than writing to it.
So we have picked <code>RWMutex</code> to serialize the access to the <code>Alive</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// SetAlive for this backend
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Backend</span><span class=p>)</span> <span class=nf>SetAlive</span><span class=p>(</span><span class=nx>alive</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>b</span><span class=p>.</span><span class=nx>mux</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
  <span class=nx>b</span><span class=p>.</span><span class=nx>Alive</span> <span class=p>=</span> <span class=nx>alive</span>
  <span class=nx>b</span><span class=p>.</span><span class=nx>mux</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
<span class=p>}</span>

<span class=c1>// IsAlive returns true when backend is alive
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Backend</span><span class=p>)</span> <span class=nf>IsAlive</span><span class=p>()</span> <span class=p>(</span><span class=nx>alive</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>b</span><span class=p>.</span><span class=nx>mux</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
  <span class=nx>alive</span> <span class=p>=</span> <span class=nx>b</span><span class=p>.</span><span class=nx>Alive</span>
  <span class=nx>b</span><span class=p>.</span><span class=nx>mux</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
  <span class=k>return</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><h2 id=lets-load-balance-requests>Lets load balance requests</h2><p>With all the background we created, we can formulate the following simple method to load balance our requests.
It will only fail when our all backends are offline.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// lb load balances the incoming request
</span><span class=c1></span><span class=kd>func</span> <span class=nf>lb</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>peer</span> <span class=o>:=</span> <span class=nx>serverPool</span><span class=p>.</span><span class=nf>GetNextPeer</span><span class=p>()</span>
  <span class=k>if</span> <span class=nx>peer</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=nx>peer</span><span class=p>.</span><span class=nx>ReverseProxy</span><span class=p>.</span><span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
    <span class=k>return</span>
  <span class=p>}</span>
  <span class=nx>http</span><span class=p>.</span><span class=nf>Error</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=s>&#34;Service not available&#34;</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusServiceUnavailable</span><span class=p>)</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><p>This method can be simply passed as a <code>HandlerFunc</code> to the http server.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>server</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Server</span><span class=p>{</span>
  <span class=nx>Addr</span><span class=p>:</span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;:%d&#34;</span><span class=p>,</span> <span class=nx>port</span><span class=p>),</span>
  <span class=nx>Handler</span><span class=p>:</span> <span class=nx>http</span><span class=p>.</span><span class=nf>HandlerFunc</span><span class=p>(</span><span class=nx>lb</span><span class=p>),</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><h2 id=route-traffic-only-to-healthy-backends>Route traffic only to healthy backends</h2><p>Our current <code>lb</code> has a serious issue. We don&rsquo;t know if a backend is healthy or not. To know this we have to try out a backend and check whether it is alive.</p><p>We can do this in two ways,</p><ul><li><strong>Active</strong>: While performing the current request, we find the selected backend is unresponsive, mark it as down.</li><li><strong>Passive</strong>: We can ping backends on fixed intervals and check status</li></ul><h2 id=actively-checking-for-healthy-backends>Actively checking for healthy backends</h2><p><code>ReverseProxy</code> triggers a callback function, <code>ErrorHandler</code> on any error. We can use that to detect any failure. Here is the implementation</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>proxy</span><span class=p>.</span><span class=nx>ErrorHandler</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>writer</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>request</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>,</span> <span class=nx>e</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;[%s] %s\n&#34;</span><span class=p>,</span> <span class=nx>serverUrl</span><span class=p>.</span><span class=nx>Host</span><span class=p>,</span> <span class=nx>e</span><span class=p>.</span><span class=nf>Error</span><span class=p>())</span>
  <span class=nx>retries</span> <span class=o>:=</span> <span class=nf>GetRetryFromContext</span><span class=p>(</span><span class=nx>request</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>retries</span> <span class=p>&lt;</span> <span class=mi>3</span> <span class=p>{</span>
    <span class=k>select</span> <span class=p>{</span>
      <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>time</span><span class=p>.</span><span class=nf>After</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>):</span>
        <span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>request</span><span class=p>.</span><span class=nf>Context</span><span class=p>(),</span> <span class=nx>Retry</span><span class=p>,</span> <span class=nx>retries</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
        <span class=nx>proxy</span><span class=p>.</span><span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>writer</span><span class=p>,</span> <span class=nx>request</span><span class=p>.</span><span class=nf>WithContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>))</span>
      <span class=p>}</span>
      <span class=k>return</span>
    <span class=p>}</span>

  <span class=c1>// after 3 retries, mark this backend as down
</span><span class=c1></span>  <span class=nx>serverPool</span><span class=p>.</span><span class=nf>MarkBackendStatus</span><span class=p>(</span><span class=nx>serverUrl</span><span class=p>,</span> <span class=kc>false</span><span class=p>)</span>

  <span class=c1>// if the same request routing for few attempts with different backends, increase the count
</span><span class=c1></span>  <span class=nx>attempts</span> <span class=o>:=</span> <span class=nf>GetAttemptsFromContext</span><span class=p>(</span><span class=nx>request</span><span class=p>)</span>
  <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s(%s) Attempting retry %d\n&#34;</span><span class=p>,</span> <span class=nx>request</span><span class=p>.</span><span class=nx>RemoteAddr</span><span class=p>,</span> <span class=nx>request</span><span class=p>.</span><span class=nx>URL</span><span class=p>.</span><span class=nx>Path</span><span class=p>,</span> <span class=nx>attempts</span><span class=p>)</span>
  <span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithValue</span><span class=p>(</span><span class=nx>request</span><span class=p>.</span><span class=nf>Context</span><span class=p>(),</span> <span class=nx>Attempts</span><span class=p>,</span> <span class=nx>attempts</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
  <span class=nf>lb</span><span class=p>(</span><span class=nx>writer</span><span class=p>,</span> <span class=nx>request</span><span class=p>.</span><span class=nf>WithContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>))</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><p>In here we leverage the power of closures to design this error handler. It allows us to capture outer variables like server url into our method.
It will check for existing retry count and if it is less than 3, we again send the same request to the same backend.
The reason behind this is due to temporary errors the server may reject your requests and it may be available after a short delay(possibly the server ran out of sockets to accept more clients). So we have put a timer to delay the retry for around 10 milliseconds. We increases the retry count with every request.</p><p>After every retry failed, we mark this backend as down.</p><p>Next thing we want to do is attempting a new backend to the same request. We do it by keeping a count of the attempts using the context package. After increasing the attempt count, we pass it back to <code>lb</code> to pick a new peer to process the request.</p><p>Now we can&rsquo;t do this indefinitely, thus we need to check from <code>lb</code> whether the maximum attempts already taken before processing the request further.</p><p>We can simply get the attempt count from the request and if it has exceeded the max count, eliminate the request.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// lb load balances the incoming request
</span><span class=c1></span><span class=kd>func</span> <span class=nf>lb</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>attempts</span> <span class=o>:=</span> <span class=nf>GetAttemptsFromContext</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>attempts</span> <span class=p>&gt;</span> <span class=mi>3</span> <span class=p>{</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s(%s) Max attempts reached, terminating\n&#34;</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>RemoteAddr</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nx>URL</span><span class=p>.</span><span class=nx>Path</span><span class=p>)</span>
    <span class=nx>http</span><span class=p>.</span><span class=nf>Error</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=s>&#34;Service not available&#34;</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusServiceUnavailable</span><span class=p>)</span>
    <span class=k>return</span>
  <span class=p>}</span>

  <span class=nx>peer</span> <span class=o>:=</span> <span class=nx>serverPool</span><span class=p>.</span><span class=nf>GetNextPeer</span><span class=p>()</span>
  <span class=k>if</span> <span class=nx>peer</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=nx>peer</span><span class=p>.</span><span class=nx>ReverseProxy</span><span class=p>.</span><span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
    <span class=k>return</span>
  <span class=p>}</span>
  <span class=nx>http</span><span class=p>.</span><span class=nf>Error</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=s>&#34;Service not available&#34;</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusServiceUnavailable</span><span class=p>)</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><p>This implementation is recursive.</p><h2 id=use-of-context>Use of context</h2><p><code>context</code> package allows you to store useful data in an Http request.
We heavily utilized this to track request specific data such as Attempt count and Retry count.</p><p>First, we need to specify keys for the context. It is recommended to use non-colliding integer keys rather than strings. Go provides <code>iota</code> keyword to implement constants incrementally, each containing a unique value. That is a perfect solution defining integer keys.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>const</span> <span class=p>(</span>
  <span class=nx>Attempts</span> <span class=kt>int</span> <span class=p>=</span> <span class=kc>iota</span>
  <span class=nx>Retry</span>
<span class=p>)</span></code></pre></td></tr></table></div></div><p>Then we can retrieve the value as usually we do with a HashMap like follows. The default return value may depend on the use case.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// GetAttemptsFromContext returns the attempts for request
</span><span class=c1></span><span class=kd>func</span> <span class=nf>GetRetryFromContext</span><span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
  <span class=k>if</span> <span class=nx>retry</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>Context</span><span class=p>().</span><span class=nf>Value</span><span class=p>(</span><span class=nx>Retry</span><span class=p>).(</span><span class=kt>int</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>retry</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=mi>0</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><h2 id=passive-health-checks>Passive health checks</h2><p>Passive health checks allow to recover dead backends or identify them. We ping the backends with fixed intervals to check their status.</p><p>To ping, we try to establish a TCP connection. If the backend responses, we mark it as alive. This method can be changed to call a specific endpoint like <code>/status</code> if you like. Make sure to close the connection once it established to reduce the additional load in the server.
Otherwise, it will try to maintain the connection and it would run out of resources eventually.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// isAlive checks whether a backend is Alive by establishing a TCP connection
</span><span class=c1></span><span class=kd>func</span> <span class=nf>isBackendAlive</span><span class=p>(</span><span class=nx>u</span> <span class=o>*</span><span class=nx>url</span><span class=p>.</span><span class=nx>URL</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
  <span class=nx>timeout</span> <span class=o>:=</span> <span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span>
  <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>DialTimeout</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=nx>u</span><span class=p>.</span><span class=nx>Host</span><span class=p>,</span> <span class=nx>timeout</span><span class=p>)</span>
  <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Site unreachable, error: &#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
    <span class=k>return</span> <span class=kc>false</span>
  <span class=p>}</span>
  <span class=nx>_</span> <span class=p>=</span> <span class=nx>conn</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span> <span class=c1>// close it, we dont need to maintain this connection
</span><span class=c1></span>  <span class=k>return</span> <span class=kc>true</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><p>Now we can iterate the servers and mark their status like follows,</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// HealthCheck pings the backends and update the status
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>ServerPool</span><span class=p>)</span> <span class=nf>HealthCheck</span><span class=p>()</span> <span class=p>{</span>
  <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>b</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span><span class=p>.</span><span class=nx>backends</span> <span class=p>{</span>
    <span class=nx>status</span> <span class=o>:=</span> <span class=s>&#34;up&#34;</span>
    <span class=nx>alive</span> <span class=o>:=</span> <span class=nf>isBackendAlive</span><span class=p>(</span><span class=nx>b</span><span class=p>.</span><span class=nx>URL</span><span class=p>)</span>
    <span class=nx>b</span><span class=p>.</span><span class=nf>SetAlive</span><span class=p>(</span><span class=nx>alive</span><span class=p>)</span>
    <span class=k>if</span> <span class=p>!</span><span class=nx>alive</span> <span class=p>{</span>
      <span class=nx>status</span> <span class=p>=</span> <span class=s>&#34;down&#34;</span>
    <span class=p>}</span>
    <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s [%s]\n&#34;</span><span class=p>,</span> <span class=nx>b</span><span class=p>.</span><span class=nx>URL</span><span class=p>,</span> <span class=nx>status</span><span class=p>)</span>
  <span class=p>}</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><p>To run this periodically we can start a timer in Go. Once a timer created it allows you to listen for the event using a channel.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// healthCheck runs a routine for check status of the backends every 20 secs
</span><span class=c1></span><span class=kd>func</span> <span class=nf>healthCheck</span><span class=p>()</span> <span class=p>{</span>
  <span class=nx>t</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>NewTicker</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>20</span><span class=p>)</span>
  <span class=k>for</span> <span class=p>{</span>
    <span class=k>select</span> <span class=p>{</span>
    <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>t</span><span class=p>.</span><span class=nx>C</span><span class=p>:</span>
      <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Starting health check...&#34;</span><span class=p>)</span>
      <span class=nx>serverPool</span><span class=p>.</span><span class=nf>HealthCheck</span><span class=p>()</span>
      <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Health check completed&#34;</span><span class=p>)</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><p>In the above snippet, <code>&lt;-t.C</code> channel will return a value per 20s. <code>select</code> allows to detect this event. <code>select</code> waits until at least one case statement could be executed if there is no <code>default</code> case.</p><p>Finally, run this in a separate goroutine.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=k>go</span> <span class=nf>healthCheck</span><span class=p>()</span></code></pre></td></tr></table></div></div><h2 id=conclusion>Conclusion</h2><p>We covered a lot of stuff in this article.</p><ul><li>Round Robin Selection</li><li>ReverseProxy from the standard library</li><li>Mutexes</li><li>Atomic Operations</li><li>Closures</li><li>Callbacks</li><li>Select Operation</li></ul><p>There is a lot we can do to improve our tiny load balancer.</p><p>For example,</p><ul><li>Use a heap for sort out alive backends to reduce search surface</li><li>Collect statistics</li><li>Implement weighted round-robin/least connections</li><li>Add support for a configuration file</li></ul><p>etc.</p><p>You can find the source code to repository <a href=https://github.com/kasvith/simplelb/>here</a>.</p><p>Thank you for reading this article 😄</p></div><footer class=post-footer><div class=post-tags><a href=/tags/go/>go</a>
<a href=/tags/golang/>golang</a>
<a href=/tags/load-balancer/>load-balancer</a></div><nav class=post-nav><a class=prev href=/posts/how-we-created-a-realtime-patient-monitoring-system-with-go-and-vue/><i class="iconfont icon-left"></i><span class="prev-text nav-default">How We Created a Realtime Patient Monitoring System With Go and Vue in 3 days</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=/posts/moving-to-my-own-space/><span class="next-text nav-default">Moving to My Own Space</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname==='localhost')return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='kasvith-github-io';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:alankasun@gmail.com class="iconfont icon-email" title=email></a><a href=https://twitter.com/kasvith class="iconfont icon-twitter" title=twitter></a><a href=https://www.facebook.com/kasvith class="iconfont icon-facebook" title=facebook></a><a href=https://www.linkedin.com/in/kasvith/ class="iconfont icon-linkedin" title=linkedin></a><a href=https://github.com/kasvith class="iconfont icon-github" title=github></a><a href=https://gitlab.com/kasvith class="iconfont icon-gitlab" title=gitlab></a><a href=https://kasvith.me/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2019 -
2020
<span class=heart><i class="iconfont icon-heart"></i></span><span class=author>Kasun Vithanage</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/dist/even.26188efa.min.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-144761237-1','auto');ga('set','anonymizeIp',true);ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>